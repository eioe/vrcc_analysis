length(unique(fulldata$ID)) # sample size before
fulldata <- fulldata[!(fulldata$ID %in% pre_exclusions), ]
length(unique(fulldata$ID))  # sample size after
# from questionnaire data:
length(unique(q_data$SUBJECT)) # sample size before
q_data <- q_data[!(q_data$SUBJECT %in% pre_exclusions), ]
length(unique(q_data$SUBJECT))
# Set up the fulldata directory
VRCC_dir        <- here()
data_dir        <- here("Data/VRTask/Logfiles/ExpSubjects")
qstnr_data_path <- here("Data/VRTask/Questionnaires/aggregates_clean")
# Build the fulldataset (Behavioral/VR data)
fulldata <- build_dataset(data_dir)
# Get the summary of questionnaire data
q_data <- read_questionnaire_data(qstnr_data_path, sheet = 1, filter_pilot = F)
### Removing the subjects with no cardiac data (temporary - to be decided)
# # Drop unused data from five subjects
pre_exclusions <- c("S11", "S13", "S18", "S21", "S44")
# from behavioral data:
length(unique(fulldata$ID)) # sample size before
fulldata <- fulldata[!(fulldata$ID %in% pre_exclusions), ]
length(unique(fulldata$ID))  # sample size after
# from questionnaire data:
length(unique(q_data$SUBJECT)) # sample size before
q_data <- q_data[!(q_data$SUBJECT %in% pre_exclusions), ]
length(unique(q_data$SUBJECT))
qstnr_data_path <- here("Data/VRTask/Questionnaires/aggregates_clean.xlsx")
# Get the summary of questionnaire data
q_data <- read_questionnaire_data(qstnr_data_path, sheet = 1, filter_pilot = F)
### Removing the subjects with no cardiac data (temporary - to be decided)
# # Drop unused data from five subjects
pre_exclusions <- c("S11", "S13", "S18", "S21", "S44")
# from behavioral data:
length(unique(fulldata$ID)) # sample size before
fulldata <- fulldata[!(fulldata$ID %in% pre_exclusions), ]
length(unique(fulldata$ID))  # sample size after
# from questionnaire data:
length(unique(q_data$SUBJECT)) # sample size before
q_data <- q_data[!(q_data$SUBJECT %in% pre_exclusions), ]
length(unique(q_data$SUBJECT))
# Drop unused levels
fulldata <- droplevels(fulldata)
View(fulldata)
fulldata$EstimatedPosition[1]
c(2, 1) - c(3, 5)
ddd = fulldata$EstimatedPosition[1]
ddd
unlist(strsplit(ddd, ","))
gsub('(|)', '', ddd)
gsub('\(|\)', '', ddd)
gsub('/(|/)', '', ddd)
gsub('\\(|\\)', '', ddd)
ddd = fulldata$EstimatedPosition[1:3]
ddd
unlist(strsplit(ddd, ","))
aaa= c(1, 2, 3)
aaa[[1, 3]]
aaa[3]
aaa[c(1, 3)]
for (i in length(aaa)) {print(i)}
for (i in seq(1:length(aaa))) {print(i)}
for (i in seq_along(aaa)) {print(i)}
position_to_numeric = function(position_vector) {
numerical_pos = c()
for (i in seq_along(position_vector)) {
pos = gsub('\\(|\\)', '', position_vector[i])
pos = unlist(strsplit(pos, ","))
pos = pos[c(1, 3)]
numerical_pos[i] = pos
}
numerical_pos
}
position_to_numeric(fulldata$EstimatedPosition[1:3])
position_to_numeric = function(position_vector) {
numerical_pos = c()
for (i in seq_along(position_vector)) {
pos = gsub('\\(|\\)', '', position_vector[i])
pos = unlist(strsplit(pos, ","))
pos = as.numeric(pos[c(1, 3)])
print(pos)
# numerical_pos[i] = pos
}
numerical_pos
}
position_to_numeric(fulldata$EstimatedPosition[1:3])
position_to_numeric = function(position_vector) {
numeric_pos = c()
for (i in seq_along(position_vector)) {
pos = gsub('\\(|\\)', '', position_vector[i])
pos = unlist(strsplit(pos, ","))
pos = as.numeric(pos[c(1, 3)])
print(pos)
numeric_pos[i] = pos
}
numerical_pos
}
position_to_numeric(fulldata$EstimatedPosition[1:3])
position_to_numeric = function(position_vector) {
numeric_pos = c()
for (i in seq_along(position_vector)) {
pos = gsub('\\(|\\)', '', position_vector[i])
pos = unlist(strsplit(pos, ","))
pos = as.numeric(pos[c(1, 3)])
print(pos)
numeric_pos[i] = pos
}
numeric_pos
}
position_to_numeric(fulldata$EstimatedPosition[1:3])
position_to_numeric = function(position_vector) {
numeric_pos = c()
for (i in seq_along(position_vector)) {
pos = gsub('\\(|\\)', '', position_vector[i])
pos = unlist(strsplit(pos, ","))
pos = as.numeric(pos[c(1, 3)])
print(pos)
numeric_pos[i] = i
}
numeric_pos
}
position_to_numeric(fulldata$EstimatedPosition[1:3])
position_to_numeric = function(position_vector) {
numeric_pos = c()
for (i in seq_along(position_vector)) {
pos = gsub('\\(|\\)', '', position_vector[i])
pos = unlist(strsplit(pos, ","))
pos = as.numeric(pos[c(1, 3)])
numeric_pos[i] = i
}
numeric_pos
}
position_to_numeric(fulldata$EstimatedPosition[1:3])
position_to_numeric = function(position_vector) {
numeric_pos = list()
for (i in seq_along(position_vector)) {
pos = gsub('\\(|\\)', '', position_vector[i])
pos = unlist(strsplit(pos, ","))
pos = as.numeric(pos[c(1, 3)])
numeric_pos[i] = pos
}
numeric_pos
}
position_to_numeric(fulldata$EstimatedPosition[1:3])
position_to_numeric = function(position_vector) {
numeric_pos = list()
for (i in seq_along(position_vector)) {
pos = gsub('\\(|\\)', '', position_vector[i])
pos = unlist(strsplit(pos, ","))
pos = as.numeric(pos[c(1, 3)])
numeric_pos[i] = pos
}
numeric_pos[[i]]
}
position_to_numeric(fulldata$EstimatedPosition[1:3])
position_to_numeric = function(position_vector) {
numeric_pos = list()
for (i in seq_along(position_vector)) {
pos = gsub('\\(|\\)', '', position_vector[i])
pos = unlist(strsplit(pos, ","))
pos = as.numeric(pos[c(1, 3)])
numeric_pos[i] = pos
}
numeric_pos[[i]]
}
position_to_numeric(fulldata$EstimatedPosition[1:3])
ggg= list()
ggg[[1]] <- c(1,2,3)
ggg[[2]] <- c(3,4,5)
ggg
position_to_numeric = function(position_vector) {
numeric_pos = list()
for (i in seq_along(position_vector)) {
pos = gsub('\\(|\\)', '', position_vector[i])
pos = unlist(strsplit(pos, ","))
pos = as.numeric(pos[c(1, 3)])
numeric_pos[[i]] = pos
}
numeric_pos
}
position_to_numeric(fulldata$EstimatedPosition[1:3])
position_to_numeric(fulldata$EstimatedPosition)
position_to_numeric(fulldata$EstimatedPosition[1:3])
ppp = position_to_numeric(fulldata$EstimatedPosition[1:3])
ppp - ppp
for (p in ppp) {print(p + p)}
mapply(ppp, ppp, SIMPLIFY = FALSE)
ppp
mapply(sum, ppp, ppp, SIMPLIFY = FALSE)
mapply(sum, ppp, SIMPLIFY = FALSE)
2**3
(c(1, 4) - c(3, 4))
sum(c(1, 4) - c(3, 4))
sum(c(1, 4) - c(3, 78))
compute_euclidean = function(pos_1, pos_2) {
sqrt(sum((pos_1 - pos_2)**2))
}
compute_euclidean(c(4, 5), c(1, 1))
ppp = c("(4, 0, 5)", "(1, 0, 1)")
position_to_numeric(ppp)
qqq = c("(1, 0, 1)", "(4, 0, 5)")
get_euclidean_dist = function(pos_1, pos_2) {
sqrt(sum((pos_1 - pos_2)**2))
}
4 != 5
4 != 4
compute_euclidean_distances(list_1, list_2) {
if (length(list_1) != length(list_2)) {
stop('\nLenghts of provided lists are not equal. List 1 has lenght of', length(list_1), 'while list 2 has length', length(list_1))
}
numeric_1 = position_to_numeric(vec_1)
numeric_2 = position_to_numeric(vec_2)
for (i in 1:length(vec_1))
}
compute_euclidean_distances(list_1, list_2) {
if (length(list_1) != length(list_2)) {
stop('\nLenghts of provided lists are not equal. List 1 has lenght of', length(list_1), 'while list 2 has length', length(list_1))
}
numeric_1 = position_to_numeric(vec_1)
numeric_2 = position_to_numeric(vec_2)
for (i in 1:length(vec_1)) {}
}
compute_euclidean_distances(list_1, list_2) {
if (length(list_1) != length(list_2)) {
stop('\nLenghts of provided lists are not equal. List 1 has lenght of', length(list_1), 'while list 2 has length', length(list_1))
}
numeric_1 = position_to_numeric(list_1)
numeric_2 = position_to_numeric(list_2)
for (i in 1:length(vec_1)) {}
}
compute_euclidean_distances(list_1, list_2) {
if (length(list_1) != length(list_2)) {
stop('\nLenghts of provided lists are not equal. List 1 has lenght of', length(list_1), 'while list 2 has length', length(list_1))
}
numeric_1 = position_to_numeric(list_1)
numeric_2 = position_to_numeric(list_2)
for (i in 1:length(list_1)) {}
}
compute_euclidean_distances(list_1, list_2) {
if (length(list_1) != length(list_2)) {
stop('\nLenghts of provided lists are not equal. List 1 has lenght of', length(list_1), 'while list 2 has length', length(list_1))
}
numeric_1 = position_to_numeric(list_1)
numeric_2 = position_to_numeric(list_2)
for (i in 1:length(list_1)) {break()}
}
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
compute_euclidean_distances = function(list_1, list_2) {
if (length(list_1) != length(list_2)) {
stop('\nLenghts of provided lists are not equal.')
}
# numeric_1 = position_to_numeric(list_1)
# numeric_2 = position_to_numeric(list_2)
}
compute_euclidean_distances = function(list_1, list_2) {
if (length(list_1) != length(list_2)) {
stop('\nLenghts of provided lists are not equal.')
}
numeric_1 = position_to_numeric(list_1)
numeric_2 = position_to_numeric(list_2)
distances = c()
for (i in 1:length(numeric_1)) {
distances[i] = get_euclidean_dist(numeric_1[i], numeric_2[i])
}
distances
}
compute_euclidean_distances(ppp, qqq)
compute_euclidean_distances = function(list_1, list_2) {
if (length(list_1) != length(list_2)) {
stop('\nLenghts of provided lists are not equal.')
}
numeric_1 = position_to_numeric(list_1)
numeric_2 = position_to_numeric(list_2)
distances = c()
for (i in 1:length(numeric_1)) {
print(numeric_1[i])
distances[i] = get_euclidean_dist(numeric_1[i], numeric_2[i])
}
distances
}
compute_euclidean_distances(ppp, qqq)
compute_euclidean_distances = function(list_1, list_2) {
if (length(list_1) != length(list_2)) {
stop('\nLenghts of provided lists are not equal.')
}
numeric_1 = position_to_numeric(list_1)
numeric_2 = position_to_numeric(list_2)
distances = c()
for (i in 1:length(numeric_1)) {
print(numeric_1[[i]])
distances[i] = get_euclidean_dist(numeric_1[i], numeric_2[i])
}
distances
}
compute_euclidean_distances(ppp, qqq)
compute_euclidean_distances = function(list_1, list_2) {
if (length(list_1) != length(list_2)) {
stop('\nLenghts of provided lists are not equal.')
}
numeric_1 = position_to_numeric(list_1)
numeric_2 = position_to_numeric(list_2)
distances = c()
for (i in 1:length(numeric_1)) {
distances[i] = get_euclidean_dist(numeric_1[[i]], numeric_2[[i]])
}
distances
}
compute_euclidean_distances(ppp, qqq)
compute_euclidean_distances(fulldata$EstimatedPosition, fulldata$TruePosition)
get_angle <- function(x, y){
dot_prod <- x%*%y
norm_x <- norm(x, type="2")
norm_y <- norm(y, type="2")
theta <- acos(dot_prod / (norm_x * norm_y))
as.numeric(theta)
}
compute_angles = function(list_1, list_2) {
# Computes angle in radians between two lists of coordinates in form e.g. "(0.67, 0.0, 0.786)",
# using `position_to_numeric()` to parse theses coordinates to a valid format, e.g. (0.67, 0.786)
if (length(list_1) != length(list_2)) {
stop('\nLenghts of provided lists are not equal.')
}
numeric_1 = position_to_numeric(list_1)
numeric_2 = position_to_numeric(list_2)
distances = c()
for (i in 1:length(numeric_1)) {
distances[i] = get_angle(numeric_1[[i]], numeric_2[[i]])
}
distances
}
source('~/Personal/Fear from  heart - Central Kollegs/centralkollegs18/Code/Analyses/VRTask/Utils/distance_utils.r', echo=TRUE)
get_angle <- function(pos_1, pos_2){
dot_prod <- pos_1 %*% pos_2
norm_1 <- norm(pos_1, type="2")
norm_2 <- norm(pos_2, type="2")
theta <- acos(dot_prod / (norm_1 * norm_2))
as.numeric(theta)
}
get_angle(c(1, 0), c(0, 1))
get_angle(c(1, 0), c(-1, 0))
get_angle(c(1, 0), c(1, 0))
get_angle(c(0, 1), c(1, 0))
get_angle(c(0, 1), c(-1, 0))
knitr::opts_chunk$set(echo = TRUE)
basic_color <- '#195e8c'
# setwd('C:\\Users\\aleksander.molak\\Documents\\Personal\\Fear from  heart - Central Kollegs\\centralkollegs18')
# Utils
library(dplyr)
library(here)
library(haven)
library(readr)
library(tibble)
library(purrr)
library(mosaic)
library(stringr)
# Plotting and tables
library(ggplot2)
library(sjPlot)
# Statistical tools
library(lme4)
library(lmtest)
library(lmerTest)
library(car)
library(BayesFactor)
require(effsize)
# Load helper functions
source(here("./Code/Analyses/VRTask/Utils/get_cardio_info.R"))
source(here("./Code/Analyses/VRTask/Utils/read_utils.r"))
source(here("./Code/Analyses/VRTask/Utils/distance_utils.r"))
# Set up the fulldata directory
VRCC_dir        <- here()
data_dir        <- here("Data/VRTask/Logfiles/ExpSubjects")
qstnr_data_path <- here("Data/VRTask/Questionnaires/aggregates_clean.xlsx")
# Build the fulldataset (Behavioral/VR data)
fulldata <- build_dataset(data_dir)
# Get the summary of questionnaire data
q_data <- read_questionnaire_data(qstnr_data_path, sheet = 1, filter_pilot = F)
### Removing the subjects with no cardiac data (temporary - to be decided)
# # Drop unused data from five subjects
pre_exclusions <- c("S11", "S13", "S18", "S21", "S44")
# from behavioral data:
length(unique(fulldata$ID)) # sample size before
fulldata <- fulldata[!(fulldata$ID %in% pre_exclusions), ]
length(unique(fulldata$ID))  # sample size after
# from questionnaire data:
length(unique(q_data$SUBJECT)) # sample size before
q_data <- q_data[!(q_data$SUBJECT %in% pre_exclusions), ]
length(unique(q_data$SUBJECT))
# Drop unused levels
fulldata <- droplevels(fulldata)
# Compute distance errors & add to the fulldataset
fulldata <- fulldata %>%
mutate(DistanceError = (EstimatedDistance - RealDistance),
DistanceErrorAbs = abs(DistanceError),
DistanceErrorNorm = DistanceError / RealDistance,
DistanceErrorNormAbs = abs(DistanceErrorNorm),
EuclideanDistanceError = compute_euclidean_distances(EstimatedPosition, TruePosition),
AngularError = compute_angles(EstimatedPosition, TruePosition)) %>%
mutate(totTrial = Trial + (Round - 1) * max(Trial)) # Labels the trials with sequential numbers over the whole experiment (1-720)
# AM: Add Euclidean & Angular Error
knitr::opts_chunk$set(echo = TRUE)
basic_color <- '#195e8c'
# setwd('C:\\Users\\aleksander.molak\\Documents\\Personal\\Fear from  heart - Central Kollegs\\centralkollegs18')
# Utils
library(dplyr)
library(here)
library(haven)
library(readr)
library(tibble)
library(purrr)
library(mosaic)
library(stringr)
# Plotting and tables
library(ggplot2)
library(sjPlot)
# Statistical tools
library(lme4)
library(lmtest)
library(lmerTest)
library(car)
library(BayesFactor)
require(effsize)
# Load helper functions
source(here("./Code/Analyses/VRTask/Utils/get_cardio_info.R"))
source(here("./Code/Analyses/VRTask/Utils/read_utils.r"))
source(here("./Code/Analyses/VRTask/Utils/distance_utils.r"))
# Set up the fulldata directory
VRCC_dir        <- here()
data_dir        <- here("Data/VRTask/Logfiles/ExpSubjects")
qstnr_data_path <- here("Data/VRTask/Questionnaires/aggregates_clean.xlsx")
# Build the fulldataset (Behavioral/VR data)
fulldata <- build_dataset(data_dir)
# Get the summary of questionnaire data
q_data <- read_questionnaire_data(qstnr_data_path, sheet = 1, filter_pilot = F)
### Removing the subjects with no cardiac data (temporary - to be decided)
# # Drop unused data from five subjects
pre_exclusions <- c("S11", "S13", "S18", "S21", "S44")
# from behavioral data:
length(unique(fulldata$ID)) # sample size before
fulldata <- fulldata[!(fulldata$ID %in% pre_exclusions), ]
length(unique(fulldata$ID))  # sample size after
# from questionnaire data:
length(unique(q_data$SUBJECT)) # sample size before
q_data <- q_data[!(q_data$SUBJECT %in% pre_exclusions), ]
length(unique(q_data$SUBJECT))
# Drop unused levels
fulldata <- droplevels(fulldata)
# Compute distance errors & add to the fulldataset
fulldata <- fulldata %>%
mutate(DistanceError = (EstimatedDistance - RealDistance),
DistanceErrorAbs = abs(DistanceError),
DistanceErrorNorm = DistanceError / RealDistance,
DistanceErrorNormAbs = abs(DistanceErrorNorm),
EuclideanDistanceError = compute_euclidean_distances(EstimatedPosition, TruePosition),
AngularError = compute_angles(EstimatedPosition, TruePosition)) %>%
mutate(totTrial = Trial + (Round - 1) * max(Trial)) # Labels the trials with sequential numbers over the whole experiment (1-720)
knitr::opts_chunk$set(echo = TRUE)
basic_color <- '#195e8c'
# setwd('C:\\Users\\aleksander.molak\\Documents\\Personal\\Fear from  heart - Central Kollegs\\centralkollegs18')
# Utils
library(dplyr)
library(here)
library(haven)
library(readr)
library(tibble)
library(purrr)
library(mosaic)
library(stringr)
# Plotting and tables
library(ggplot2)
library(sjPlot)
# Statistical tools
library(lme4)
library(lmtest)
library(lmerTest)
library(car)
library(BayesFactor)
require(effsize)
# Load helper functions
source(here("./Code/Analyses/VRTask/Utils/get_cardio_info.R"))
source(here("./Code/Analyses/VRTask/Utils/read_utils.r"))
source(here("./Code/Analyses/VRTask/Utils/distance_utils.r"))
# Set up the fulldata directory
VRCC_dir        <- here()
data_dir        <- here("Data/VRTask/Logfiles/ExpSubjects")
qstnr_data_path <- here("Data/VRTask/Questionnaires/aggregates_clean.xlsx")
# Build the fulldataset (Behavioral/VR data)
fulldata <- build_dataset(data_dir)
# Get the summary of questionnaire data
q_data <- read_questionnaire_data(qstnr_data_path, sheet = 1, filter_pilot = F)
### Removing the subjects with no cardiac data (temporary - to be decided)
# # Drop unused data from five subjects
pre_exclusions <- c("S11", "S13", "S18", "S21", "S44")
# from behavioral data:
length(unique(fulldata$ID)) # sample size before
fulldata <- fulldata[!(fulldata$ID %in% pre_exclusions), ]
length(unique(fulldata$ID))  # sample size after
# from questionnaire data:
length(unique(q_data$SUBJECT)) # sample size before
q_data <- q_data[!(q_data$SUBJECT %in% pre_exclusions), ]
length(unique(q_data$SUBJECT))
# Drop unused levels
fulldata <- droplevels(fulldata)
# Compute distance errors & add to the fulldataset
fulldata <- fulldata %>%
mutate(DistanceError = (EstimatedDistance - RealDistance),
DistanceErrorAbs = abs(DistanceError),
DistanceErrorNorm = DistanceError / RealDistance,
DistanceErrorNormAbs = abs(DistanceErrorNorm),
EuclideanDistanceError = compute_euclidean_distances(EstimatedPosition, TruePosition),
AngularError = compute_angles(EstimatedPosition, TruePosition)) %>%
mutate(totTrial = Trial + (Round - 1) * max(Trial)) # Labels the trials with sequential numbers over the whole experiment (1-720)
