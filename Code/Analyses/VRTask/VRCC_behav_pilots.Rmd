---
title: "VRCC Analyses Behav Pilot Data"
author: "FK & PM"
date: "12 Februar 2019"
contact: "klotzsche@cbs.mpg.de"
output: html_document
editor_options: 
  chunk_output_type: console
chunk_output_type: console
self_contained: no
---

```{r}
# install.packages('here')
require(ggplot2)
require(dplyr)
require(lmtest)
require(here)
require(haven)
require(readr)
require(purrr)
require(tibble)

source("./Utils/get_cardio_info.R")

# Load data sets:

# send me to VRCC dir:
VRCC_dir <- here()

# Set up the data directory
data_dir <- here("Data/VRTask/Logfiles/ExpSubjects")
dat <- NULL
data <- NULL

### Subject 19 ###

# I assume this will be a loop over the subj folders in Data/VRTask/Logfile.
#  For now I set the folder (missing in the read.table call below) manually:

subj_ID <- "S19"

dat <- read.table(file.path(data_dir, 
                            subj_ID, 
                            "S19_PlayerLog_15-55-38-01-03-2019.txt"),
                  skip      = 6,
                  header    = T,
                  sep       = ";",
                  row.names = NULL,
                  na.string = "-1.0000")

#mismatched columns - shifting names of the columns               ### TRY TO CLEAN THIS!!! Tidyverse might help 
get_names <- colnames(dat)            
updated_names <- get_names[c(2:19)] # remove the first name
colnames(dat) <- updated_names # now the order is ok.
dat <- dat[,1:18]

# cut to relevant rows:
dat <- dat[dat$Phase == "Estimation",  ]   ### Pick estimations only (filter-out other observations)
dat <- dat[dat$Training == "False",  ]     ### Filter-out training (this is the training for the depth estimation [Stimuluss visible])
dat <- dat[dat$Round > 0, ]                ### Filer-out 2nd training ("real" training with other Stimuluss) 

# We should end up with 720 observations     #

# save to list:
dat$who <- as.factor(subj_ID)
data[[1]] <- dat
dat <- NULL


### Subject 6 ###
subj_ID <- "S06"
dat <- read.table(file.path(data_dir, 
                            subj_ID, 
                            "S06_PlayerLog_12-58-47-27-02-2019.txt"),     # AM: automate based solely on "S__"
                  skip = 6,
                  header = T,
                  sep = ";",
                  row.names = NULL,
                  na.string = "-1.0000")

#mismatched columns - shifting names of the columns
get_names <- colnames(dat)
updated_names <- get_names[c(2:19)] # remove the first name
colnames(dat) <- updated_names # now the order is ok.
dat <- dat[,1:18]

# cut to relevant rows:
dat <- dat[dat$Phase == "Estimation",  ]
dat <- dat[dat$Training == "False",  ]
dat <- dat[dat$Round > 0, ]   

### I'm not sure why we end up with 725 observations 
# >> "real" training blocks come in clusters of 5; S19 apparantly did two rounds
# of "real" training (that's possible)

### **AM 05-05-2019**: Now we get 720 rows per participant

# save to list:
dat$who <- as.factor(subj_ID)
data[[2]] <- dat
dat <- NULL

# merge data sets:
fulldat <- rbind(data[[2]], data[[1]])

```


Checks & creating new variables


```{r}
  
# count threatening and non-threatening animals
length(which(fulldat$FearObject == T))
length(which(fulldat$FearObject == F))
# [FK:] I don't know what these lines do; 
# Anyway, we should do:
fulldat <- droplevels(fulldat)

# calc. error:
fulldat <- fulldat %>% 
  mutate(err = (EstimatedDistance - RealDistance),
         errAbs = abs(err),
         errNorm = err / RealDistance,
         errAbsNorm = abs(errNorm)) %>% 
  mutate(totTrial = Trial + (Round - 1) * max(Trial))

# These below needs to be updated to skip NA     ### Returns NA - but not maybe necessary no
# [FK:] Works fine for me, maybe after discarding the training trials
meansStim <- fulldat %>%
  group_by(FearObject) %>%
    summarise(meanErr = mean(err, na.rm=T),
              meanErrNorm = mean(errNorm, na.rm=T),
              meanErrAbs = mean(errAbsNorm, na.rm=T))

meansAnim <- fulldat %>%
  group_by(Stimulus) %>%
    summarise(meanErr = mean(err, na.rm=T),
              meanErrNorm = mean(errNorm, na.rm=T),
              meanErrAbs = mean(errAbsNorm, na.rm=T))

```


Add the cardio information to the data frame (fulldat): (NEEDS UPDATING)
```{r}


# for whom do we want to add cardio info:
# (skipping first 2 pilots as there's no (reasonable) cardio info for them )
#cardio_subjs <- levels(fulldat$who)[-2] 
cardio_subjs <- c('S19','S06')
cardio_dat <- NULL;

#### AM: BELOW: Type mismatch - `factor` and `character` vectors

for (part in cardio_subjs) {                               # AM: put in a function
  cardio_dat_t <- get_cardio_info(fulldat, part)
  cardio_dat <- bind_rows(cardio_dat, cardio_dat_t)
}

# add it to fulldat:
fulldat <- full_join(fulldat, cardio_dat)                 # AM: add writing to disk with datetime

```
<br><br>
____________________________________
## **AM:** BELOW: TEMP/EXPLORATORY CODE

Let's look into some features of the full data set: (NEEDS UPDATING - NEW NAMES OF VARIABLES)
```{r}
## Influence of trueDistance:
lmErrDist <- lm(err ~ RealDistance, data = fulldat)

plot(lmErrDist)

# studentized Breusch-Pagan test to test for homoscedasticity:
bptest(lmErrDist, data = fulldat)
# good!

summary(lmErrDist)
# ups...
plot(err ~ RealDistance, data = fulldat)


errHist <- ggplot(fulldat, aes(x = err, fill = FearObject)) + 
  geom_histogram(binwidth = 0.01, position = "identity", alpha = 0.5) + 
  xlim(-1, 1)  +
  geom_density(alpha = 0.2) +
  geom_vline(data=meansStim, aes(xintercept = meanErr, color = FearObject), 
             linetype = 'dashed', size = 1) +
  scale_fill_manual(values = c('blue', 'red')) + 
  scale_color_manual(values = c('blue', 'red')) +
  labs(x = "Distance Error [m]") + 
  theme_classic()
    
  
errHist


boxplot(err ~ isSystTrial, data = fulldat)
lines(mean(fulldat$err[fulldat$FearObject]), 0)


```

```{r}

d <- fulldat[fulldat$who %in% c("S06", "S19"), ]
require(circular)

for (p in unique(d$who)) {

temp_onset <- circular(d$relPosRRrad[d$who== p], type="angles", units="radians", rotation="clock", zero=pi/2) 
temp_onset <- temp_onset[!is.na(temp_onset)]

# test uniformity of onset distribution for a particpant and save the results
  onset_distribution_individual <- rayleigh.test(temp_onset) 

# show test statistics and p-value for a participant
  print(onset_distribution_individual)

plot(temp_onset, stack=TRUE, col = "gray25", cex = 0.77, main = paste("Onsets ID:", p, "\n p value:", round(onset_distribution_individual$p.value, 3), " / mean resultant length:", round(onset_distribution_individual$statistic,2)))
  rose.diag(temp_onset, bins = 16, col = "cadetblue4", prop = 2.5, add = T, axes = F)
  circ.dens = density(temp_onset, bw=40)
  lines(circ.dens, col="lightcyan3", lwd = 3, xpd=TRUE)
  
}


  
```


```{r}


for (p in unique(d$who)) {

med_value_fear <- median(d$err[d$who == p & d$FearObject == T])
med_value_non_fear <- median(d$err[d$who == p & d$FearObject == F])

for (t in 1:720) {
  
ifelse(d$err[d$who == p & d$totTrial == t & d$FearObject == T] < med_value_fear, d$closer_fear[d$who == p & d$totTrial == t] <- T, d$closer_fear[d$who == p & d$totTrial == t] <- F)

ifelse(d$err[d$who == p & d$totTrial == t & d$FearObject == F] < med_value_non_fear, d$closer_nonfear[d$who == p & d$totTrial == t] <- T, d$closer_nonfear[d$who == p & d$totTrial == t] <- F) 
}
}

#length(d$closer_fear[d$closer_fear == TRUE & d$closer_fear != NA])
#length(d$closer_nonfear[d$closer_nonfear == T & d$closer_nonfear != NA])

threat <- circular(d$relPosRRrad[d$closer_fear == T], type="angles", units="radians", rotation="clock", zero=pi/2)
threat <- threat[!is.na(threat)]

non_threat <- circular(d$relPosRRrad[d$closer_nonfear == T], type="angles", units="radians", rotation="clock", zero=pi/2)
non_threat <- non_threat[!is.na(non_threat)]

# plot the distribution of mean hits within RR interval across participants - with 0 indicating the R peak previous to the stimulus onset
plot(threat, stack= FALSE , bins = 720, col = "gray", cex = 0.7, lwd = 1, main = " ")
points(non_threat, stack = FALSE, col = "gray", cex = 0.01, lwd = 1)

# add arrows representing mean hits for each participant
arrows.circular(threat, col =  rgb(0.55, 0.23, 0.23, 0.1), lwd = 1, length = 0.001)
arrows.circular(non_threat, col = rgb(0.247, 0.435, 0.545, 0.1), lwd = 1, length = 0.001)

# add an arrow representing grand mean for hits - with its length signifying resultant length of the grand mean
arrows.circular(mean(threat), y=rho.circular(threat), lwd = 3, col = rgb(0.45, 0.13, 0.13, 0.75), length = 0.08)
arrows.circular(mean(non_threat), y=rho.circular(non_threat), lwd = 3, col = rgb(0.147, 0.285, 0.395, 0.75), length = 0.08)

# add line signifying distribution of hits (bandwidth = 20)
circ.dens = density(threat, bw=20)
lines(circ.dens, col= rgb(0.55, 0.23, 0.23), lwd = 1.5, xpd=TRUE)

circ.dens = density(non_threat, bw=20)
lines(circ.dens, col= rgb(0.247, 0.435, 0.545), lwd = 1.5, xpd=TRUE)



```


```{r}


for (p in unique(d$who)) {

  
  for (a in unique(d$Stimulus)) {

name <- paste("med_value_",a,sep="")
med <- assign(name, median(d$err[d$who == p & d$Stimulus == a]))

for (t in 1:720) {

d$closer[d$who == p & d$totTrial == t & d$Stimulus == a & d$err < med] <- T
  
#ifelse(d$err[d$who == p & d$totTrial == t & d$Stimulus == a] < med_value_fear, d$closer[d$who == p & d$totTrial == t & d$Stimulus == a] <- T)

}
}
}


#length(d$closer_fear[d$closer_fear == TRUE & d$closer_fear != NA])
#length(d$closer_nonfear[d$closer_nonfear == T & d$closer_nonfear != NA])

threat <- circular(d$relPosRRrad[d$closer == T & d$FearObject == T], type="angles", units="radians", rotation="clock", zero=pi/2)
threat <- threat[!is.na(threat)]

non_threat <- circular(d$relPosRRrad[d$closer == T & d$FearObject == F], type="angles", units="radians", rotation="clock", zero=pi/2)
non_threat <- non_threat[!is.na(non_threat)]

# plot the distribution of mean hits within RR interval across participants - with 0 indicating the R peak previous to the stimulus onset
plot(threat, stack= FALSE , bins = 720, col = "gray", cex = 0.7, lwd = 1, main = " ")
points(non_threat, stack = FALSE, col = "gray", cex = 0.01, lwd = 1)

# add arrows representing mean hits for each participant
arrows.circular(threat, col =  rgb(0.55, 0.23, 0.23, 0.1), lwd = 1, length = 0.001)
arrows.circular(non_threat, col = rgb(0.247, 0.435, 0.545, 0.1), lwd = 1, length = 0.001)

# add an arrow representing grand mean for hits - with its length signifying resultant length of the grand mean
arrows.circular(mean(threat), y=rho.circular(threat), lwd = 3, col = rgb(0.45, 0.13, 0.13, 0.75), length = 0.08)
arrows.circular(mean(non_threat), y=rho.circular(non_threat), lwd = 3, col = rgb(0.147, 0.285, 0.395, 0.75), length = 0.08)

# add line signifying distribution of hits (bandwidth = 20)
circ.dens = density(threat, bw=20)
lines(circ.dens, col= rgb(0.55, 0.23, 0.23), lwd = 1.5, xpd=TRUE)

circ.dens = density(non_threat, bw=20)
lines(circ.dens, col= rgb(0.247, 0.435, 0.545), lwd = 1.5, xpd=TRUE)




```



```{r}



for (p in unique(d$who)) {

  
  for (a in unique(d$Stimulus)) {

name <- paste("med_value_",a,sep="")
med <- assign(name, median(d$err[d$who == p & d$Stimulus == a]))

for (t in 1:720) {

d$closer[d$who == p & d$totTrial == t & d$Stimulus == a & d$err < med] <- T
  
#ifelse(d$err[d$who == p & d$totTrial == t & d$Stimulus == a] < med_value_fear, d$closer[d$who == p & d$totTrial == t & d$Stimulus == a] <- T)

}
}
}


means_threat <- vector()
means_nonthreat <- vector()

for (p in unique(d$who)) {
  
threat <- circular(d$relPosRRrad[d$who == p & d$closer == T & d$FearObject == T], type="angles", units="radians", rotation="clock", zero=pi/2)
threat <- threat[!is.na(threat)]

means_threat[p] <- mean(threat)

non_threat <- circular(d$relPosRRrad[d$who == p & d$closer == T & d$FearObject == F], type="angles", units="radians", rotation="clock", zero=pi/2)
non_threat <- non_threat[!is.na(non_threat)]

means_nonthreat[p] <- mean(non_threat)
}

# save the vector with the mean hits for each particiapant as a circular object
means_threat <- circular(means_threat, type="angles", units="radians", rotation="clock", zero=pi/2)

means_nonthreat <- circular(means_nonthreat, type="angles", units="radians", rotation="clock", zero=pi/2)

# plot the distribution of mean hits within RR interval across participants - with 0 indicating the R peak previous to the stimulus onset
plot(means_threat, stack= FALSE , bins = 720, col = "gray", cex = 0.7, lwd = 1, main = " ")
points(means_nonthreat, stack = FALSE, col = "gray", cex = 0.01, lwd = 1)

# add arrows representing mean hits for each participant
arrows.circular(means_threat, col =  "darkred", lwd = 1, length = 0.001)
arrows.circular(means_nonthreat, col = "darkblue", lwd = 1, length = 0.001)

# add an arrow representing grand mean for hits - with its length signifying resultant length of the grand mean
arrows.circular(mean(means_threat), y=rho.circular(means_threat), lwd = 3, col = rgb(0.45, 0.13, 0.13, 0.75), length = 0.08)
arrows.circular(mean(means_nonthreat), y=rho.circular(means_nonthreat), lwd = 3, col = rgb(0.147, 0.285, 0.395, 0.75), length = 0.08)

# add line signifying distribution of hits (bandwidth = 20)
circ.dens = density(means_threat, bw=20)
lines(circ.dens, col= rgb(0.55, 0.23, 0.23), lwd = 1.5, xpd=TRUE)

circ.dens = density(means_nonthreat, bw=20)
lines(circ.dens, col= rgb(0.247, 0.435, 0.545), lwd = 1.5, xpd=TRUE)



```

